<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>norcal.rodeo</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh;
            background: black;
            overflow: hidden;
            /*position: relative;*/
            position: fixed;
            boxShadow: inset 0 0 200px 100px rgba(255, 255, 255, 0.3);
        }

        #glow {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /*box-shadow: inset 0 0 200px 100px rgba(255, 255, 255, 0.3);*/
            pointer-events: none;
        }

        #rightdesc {
            position: fixed;
            top: 0;
            left: 100%;
            width: 25%;
            height: 100%;
            flex-direction: column;
        }

        .duh {
            position: absolute;
            font-family: 'Courier New', monospace;
            color: white;
            font-size: 24px;
            /*white-space: pre;*/
            line-height: 1.2;
            /*top: 50%;*/
            /*left: 50%;*/
            /*transform: translate(-50%, -50%);*/
        }
    </style>
</head>
<body>
    <div id="glow"></div>
    <div id="rightdesc"></div>

    <script>
        let duck = document.createElement('pre');
        duck.className = 'duh';
        document.body.appendChild(duck);

        let t1 = document.createElement('a');
        t1.className = 'duh';
        t1.href = "https://norcal.rodeo";
        t1.textContent = 'norcal.rodeo';
        document.body.appendChild(t1);
        let t1hov = 0;
        t1.onmouseenter = () => t1hov = 1;
        t1.onmouseleave = () => t1hov = 0;

        let t2 = document.createElement('a');
        t2.className = 'duh';
        t2.href = "http://mc.norcal.rodeo:8070/";
        t2.textContent = 'bluemap';
        document.body.appendChild(t2);
        let t2hov = 0;
        t2.onmouseenter = () => t2hov = 1;
        t2.onmouseleave = () => t2hov = 0;

        // Create a container for the text inside the right panel
        let rdc = document.createElement('div'); // rdc = rightward description content :>
        rdc.style.padding = '40px'; // Your "margin/padding"
        // rdc.style.color = 'rgba(255, 255, 255, 0)';
        rdc.style.fontFamily = "'Courier New', monospace";
        // rdc.style.whiteSpace = 'pre-wrap'; 
        rdc.innerHTML = "<h2>skbdi</h2><p><i>θ</i>: garp</p><p><i>ω</i>: terp</p><p><i>α</i>: perp</p>";

        // Append it to the rightdesc div instead of the body
        document.getElementById('rightdesc').appendChild(rdc);

        let mouseX = 0;
        let mouseY = 0;

        // Update position whenever mouse moves
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        function w() {
            return window.innerWidth
        }
        function h() {
            return window.innerHeight
        }

        // const duck = document.getElementById('duck');
        // const duckbox = duck.getBoundingClientRect();
        const glow = document.getElementById('glow');
        let t = 0;
        // const r = 10
        const dt = 0.01;
        let right = Math.PI
        let left = 0
        let duckrot = left
        let duckrotdes = right
        let rx = 0
        let ry = 0
        let vert = 0
        let hort = 0
        let acc = 100
        let dir = 0
        let duckvel = 0
        let duckacc = 0
        let duckdampen = 0.03
        let dx = 0
        let dy = 0
        let vx = 0
        let vy = 0
        let ldamp = 0.1
        let starting = true
        let nextblink = 0.5
        let lastblink = 0
        let holdblink = 0.2
        let spinscore = 0
        let torpor = 0
        let budgingright = 0
        let leftbudge = 0
        let rightbudge = 0
        mouseX = w()/4
        mouseY = h()/2

        function relativeAngle(target, current) {
            let diff = (target - current) % (2 * Math.PI);
            if (diff > Math.PI) diff -= 2 * Math.PI;
            if (diff < -Math.PI) diff += 2 * Math.PI;
            return diff;
        }
        function rand(min = -1, max = 1) {
            return Math.random()*(max-min)+min  
        }

        function animate() {

            // duck :

            let cx = window.innerWidth / 2;
            let cy = window.innerHeight / 2;
            if (starting) {dx = cx; vx = cx;dy = cy; vy = cy; starting = false}
            // const cx = 0;
            // const cy = 0;
            cx += leftbudge/2 -rightbudge/2

            let dim = window.innerWidth;
            if (window.innerHeight < dim) {
                dim = window.innerHeight;
            };  

            duckrot = duckrot % (2 * Math.PI);
            // let dx = cx + Math.sin(t) * dim * 0.1;
            // let dy = cy + Math.sin(t*0.75) * dim * 0.1;

            rx = 2*(dx - mouseX)
            ry = 2*(dy - mouseY)
            hort = Math.max(-1, Math.min(rx/window.innerWidth, 1)) // clamped cuz it was buggin crazy
            vert = Math.max(-1, Math.min(ry/window.innerHeight,1))

            let touchy = Math.max(0, (1-Math.abs(hort)) * (1-Math.abs(vert)) - 0.6)*dim/10

            const rad = 0.03
            let desx = cx + Math.sin(t*1.00) * dim * rad
            let desy = cy + Math.sin(t*0.75) * dim * rad - dim/10
            desx += touchy * (hort**1)*25
            desy += touchy * (vert**1)*10
            dx = desx
            dy = desy
            vx = (1-ldamp)*vx + ldamp*desx
            vy = (1-ldamp)*vy + ldamp*desy
            vx = Math.max(dim/4, Math.min(vx, window.innerWidth -dim/4))
            vy = Math.max(dim/4, Math.min(vy, window.innerHeight-dim/4))

            if ( hort > 0 ){
                duckrotdes = left
            } else {
                duckrotdes = right
            };

            let wrightdiv = w()/3
            if (mouseX > w()-dim/10) {
                budgingright = budgingright*0.9 + 0.1
            } else if (mouseX < w()-wrightdiv) {
                budgingright = budgingright*0.9
            }

            if (t > (lastblink + nextblink + holdblink)) {
                lastblink = t
                holdblink = rand(0, 0.07)
                nextblink = 2*rand(0,1)**2 + holdblink
            }

            spinscore = Math.max(0, Math.min(spinscore-0.01, 8))  
            if (Math.abs(duckvel) > Math.PI*7) {
                spinscore += 0.05
            }

            if (spinscore > 6) {
                duck.textContent = "-(x)__\n (_~_/";
                if (torpor < 1) { duckvel = 2*duckvel } // make him spin out
                torpor = 1
            } else if (spinscore > 3) {
                duck.textContent = "-(o)__\n (_~_/";
                if (torpor == 1) { torpor = 0.995 } // how fast the duck gonna spin just after waking back up
            } else if (((t > lastblink + nextblink) & (t < (lastblink + nextblink + holdblink)))) {
                duck.textContent = ">(-)__\n (_~_/";
            } else {
                duck.textContent = ">(o)__\n (_~_/";
                torpor = 0
            }
            // console.log((t > lastblink) && (t < (t + nextblink)))

            let mag = relativeAngle(duckrotdes, duckrot)
            if (Math.abs(mag) > 0.1) {
                dir = mag/Math.abs(mag)
            } else {
                dir = 0
            }

            let h2 = Math.abs(hort)
            acc = 500*Math.abs(hort)
            let torp = 1-torpor

            duckacc = acc * dir
            // duckacc = Math.sin(mag)
            duckvel += duckacc * dt * (1-torpor)
            if (torpor < 1) {
                duckvel = duckvel * ((1-duckdampen)+duckdampen*mag/Math.PI)
            } else {
                duckvel = 0.985 * duckvel
            }
            duckrot += duckvel * dt

            // duck.textContent = `>(o)__\n (_~_/`

            function shad(o = 1, vig = h2) { 
                return  `
                    0px 0px ${100-rand(80,100)*(vig)}px rgba(${0}, ${255}, ${0}, ${o}),
                    0px 0px ${80 -rand(70,80) *(vig)}px rgba(${255}, ${255}, ${255}, ${o}),
                    0px 0px ${60 -rand(50,60) *(vig)}px rgba(${255}, ${255}, ${0}, ${o}),
                    0px 0px ${50 -rand(40,50) *(vig)}px rgba(${255}, ${255}, ${255}, ${o}),
                    0px 0px ${40 -rand(30,40) *(vig)}px rgba(${0}, ${255}, ${255}, ${o}),
                    ${40*rand()*vig}px ${5*rand()}px 3px rgba(${255}, ${0}, ${0}, ${o}),
                    ${20*rand()*vig}px ${5*rand()}px 3px rgba(${0}, ${255}, ${255}, ${o})`
            }
            
            duck.style.fontSize = 24+Math.random()*1 + 'px';
            duck.style.color = `rgba(${255}, ${220+35*Math.random()}, ${200}, 255)`;
            // duck.style.transform = `translate(${dx}px, ${dy}px) translate(-50%, -50%) scaleX(${Math.cos(duckrot)})`;
            duck.style.transform = `translate(${vx}px, ${vy - 0.01*dim/t}px) translate(-50%, -100%) scale(${Math.cos(duckrot)}, ${1-0.2*Math.abs(vert)}) skewY(${Math.sin(duckrot)*vert*0.5}rad)`;
            duck.style.textShadow = shad()

            // text :

            let dist = dim/10
            let stiff = 0.5
            t1.style.transform = `translate(${((1+stiff)*cx+(1-stiff)*vx)/2 - dim/100*Math.sin(t)}px, ${cy - dim/100*Math.sin(0.8*t) + 0.5*dist + 0.01*dim/t}px) translate(-50%, -100%)`
            t1.style.textShadow = shad(0.5, h2 - t1hov*0.5)
            t1.style.textDecoration = `none`
            t1.style.color = `rgba(${rand(255, 255*(1-t1hov))}, 255, ${rand(255, 255*(1-t1hov))}, ${0.5 + 0.5*t1hov})`
            t1r = t1.getBoundingClientRect()

            stiff = (stiff+1)/2
            t2.style.transform = `translate(${((1+stiff)*cx+(1-stiff)*vx)/2 - dim/100*Math.sin(-0.8*t)}px, ${cy - dim/100*Math.sin(-0.5*t) + dist + 0.01*dim/t}px) translate(-50%, -100%)`
            t2.style.textShadow = shad(0.5, h2 - t2hov*0.5)
            t2.style.textDecoration = `none`
            t2.style.color = `rgba(${rand(255, 255*(1-t2hov))}, ${rand(255, 255*(1-t2hov))}, 255, ${0.5 + 0.5*t2hov})`

            // glow :

            leftbudge = 0
            rightbudge = w()/3*budgingright
            rightdesc.style.width = rightbudge + 'px';
            
            let marg = dim/16
            o2 = budgingright*2-1

            glow.style.boxShadow = `
                inset 0 0 ${rand(1,2)*dim/100}px ${marg}px rgba(0, 0, 0, 255),
                inset 0 0 ${dim/2}px ${(Math.sin(t)*0.1+0.9)*dim/3}px rgba(${rand(200,210)}, ${rand(200,210)}, ${rand(240,255)}, ${Math.random()*0.01+(0.1*Math.sin(t*2)+2)*0.03})`;
            // glow.style.transform = `scaleX(${(w()-leftbudge-rightbudge)/w()}) translate(${(leftbudge-rightbudge)/2}px, 0px)`
            rightdesc.style.boxShadow = `0 0 ${rand(1,2)*dim/100}px ${0}px rgba(0, 0, 0, 255)`
            rightdesc.style.background = `rgba(0, 0, 0, 255)`
            rightdesc.style.transform = `translate(-${rightbudge+marg}px, 0px)`
            rdc.style.color = `rgba(255, 255, 255, ${o2} )`
            rdc.innerHTML = `
                <h2>norcal.rodeo is my minecraft server</h2>
                <p>its <u>geyser enabled</u>, meaning ur bedrock friends can play too :></p>
                plugins make it so that:<ul>
                    <li>chests loot is instanced per-player</li>
                    <li>sleeping warps time instead of skipping</li>
                    <li>you can make maps from images</li>
                    <li>player heads drop</li>
                    <li>death items are stored in a grave</li>
                    <li>terralith etc; the world is prettier</li>
                    <li>w compatibility for som client mods<ul>
                        <li>appleskin</li>
                        <li>axiom</li>
                        <li>jade, sodium, etcblablabla</li>
                    </ul></li>
                    <li>more but i forgot</li>
                </ul>` 
            rdc.style.textShadow = `
                ${8*rand()}px ${5*rand()}px 3px rgba(${0}, ${0.5*(Math.sin(t)+0.5)*128}, ${(1-0.5*(Math.sin(t)+0.5))*255}, ${o2}),
                0px 0px ${rand(10,20)}px rgba(${255}, ${255}, ${255}, ${o2})`;

            t += dt;
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>



<!-- 




,.,,.,,v,.v,.V.v,.,,.,v,.,.v.,.V,..
.  `  `
- v ,  `, _
           \_______.-------  

 -->